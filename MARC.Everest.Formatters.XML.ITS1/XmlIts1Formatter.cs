/* 
 * Copyright 2008-2013 Mohawk College of Applied Arts and Technology
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you 
 * may not use this file except in compliance with the License. You may 
 * obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations under 
 * the License.

 * 
 * User: Justin Fyfe
 * Date: 01-09-2009
 */
using System;
using System.Collections.Generic;
using System.Text;
using MARC.Everest.Connectors;
using System.Reflection;
using MARC.Everest.Attributes;
using System.CodeDom;
using MARC.Everest.DataTypes;
using System.CodeDom.Compiler;
using MARC.Everest.Exceptions;
using System.Xml;
using MARC.Everest.Interfaces;
using MARC.Everest.Xml;
using System.Reflection.Emit;
using System.IO;
using System.ComponentModel;
using System.Threading;
using System.Collections;
using MARC.Everest.Formatters.XML.ITS1.Reflector;
using MARC.Everest.DataTypes.Interfaces;
using MARC.Everest.Formatters.XML.ITS1.CodeGen;
using System.Linq;

#if WINDOWS_PHONE
using MARC.Everest.Phone;
#else
using Microsoft.CSharp;
using System.Runtime.Serialization.Formatters.Binary;
using MARC.Everest.Threading;
#endif

namespace MARC.Everest.Formatters.XML.ITS1
{

    /// <summary>
    /// A linked class to <see cref="T:MARC.Everest.Formatters.XML.ITS1.XmlIts1Formatter"/> that
    /// exists to retain backwards compatibility with pre 1.0 versions of Everest
    /// </summary>
    [Obsolete("Use XmlIts1Formatter instead", false)]
    public sealed class Formatter : XmlIts1Formatter
    {
    }

    /// <summary>
    /// This is a generic formatter that reflects a type(s) and writes methods for 
    /// graphing RMIM objects using the ITS1.0 formatting rules.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The XML ITS 1.0 formatter is designed to use two different methods of formatting
    /// in order to speed up the Parse and Graph operations.
    /// </para>
    /// <para>
    /// Whenever the formatter encounters an RMIM structure which does not have a graph aide,
    /// it will check its type cache to determine if formatting can be done via generated code
    /// (provided via code-dom). If there is a cache miss, the formatter will branch a new 
    /// thread to "learn" the message and will continue formatting operations using Reflection.
    /// </para>
    /// <para>
    /// This type of algorithm allows the formatter to become faster and more efficient the 
    /// longer it runs in memory. The algorithms used in memory are controlled via the <see cref="P:Settings"/>
    /// property. By default the Formatter will select the following settings:
    /// </para>
    /// <list type="table">
    ///     <listheader>
    ///         <term>Condition</term>
    ///         <description>Setting</description>
    ///     </listheader>
    ///     <item>
    ///         <term>Single Processor</term>    
    ///         <description>This setting will not use code-dom and will opt for reflection only formatting</description>
    ///     </item>
    ///     <item>
    ///         <term>Multi Processor</term>
    ///         <description>This setting will use generated formatter classes when available. If no generated class is available, code-dom is used to "learn" the message type and reflection is used to serialize</description>
    ///     </item>
    /// </list>
    /// <para>
    /// Furthermore, this formatter can be optimized during initialization using the <see cref="F:BuildCache"/> and 
    /// <see cref="F:AddFormatterAssembly"/> methods. These methods force the formatter to "learn" structure prior
    /// actually serializing them. In the case of <see cref="F:AddFormatterAssembly"/>, it is possible to load an 
    /// assembly that was previously generated by the formatter into memory and add the data to its cache.
    /// </para>
    /// </remarks>
    /// <example>
    /// <code title="Creating and using Formatters" lang="cs">
    /// <![CDATA[
    /// using System; 
    /// using MARC.Everest.RMIM.CA.R020402.Interactions; 
    /// using MARC.Everest.RMIM.CA.R020402.Vocabulary; 
    /// using System.IO; using System.Xml; 
    /// using MARC.Everest.RMIM.CA.R020402.MCCI_MT002100CA; 
    /// using MARC.Everest.Formatters.XML.ITS1; 
    /// using MARC.Everest.Xml; 
    /// namespace EverestConsoleApplication1 { 
    ///    class Program { 
    ///        static void Main(string[] args) 
    ///        {
    ///            // Memory stream, used to store the data in memory.
    ///            MemoryStream memstream = null;
    ///
    ///            // File stream, used to store the data in a file.
    ///            FileStream fs = null;
    ///
    ///            // Create an XML Writer that will write to the memory stream (when flushed) 
    ///            // and will indent the output text.
    ///            XmlStateWriter writer = null;
    ///
    ///            //declaring the XML Formattter. 
    ///            XmlIts1Formatter xmlF = new XmlIts1Formatter(); 
    ///
    ///
    ///            //Instance to graph to XML, only contains the mandatory values. 
    ///            PRPA_IN101103CA data = new PRPA_IN101103CA(
    ///                Guid.NewGuid(),
    ///                DateTime.Now,
    ///                ResponseMode.Immediate,
    ///                PRPA_IN101103CA.GetInteractionId(),
    ///                PRPA_IN101103CA.GetProfileId(),
    ///                ProcessingID.Production,
    ///                AcknowledgementCondition.Always,
    ///                new Receiver(new Device2(Guid.NewGuid())),
    ///                new Sender(new Device1(Guid.NewGuid()))
    ///            );
    ///
    ///            // Populate the Control Act Event with mandatory values. 
    ///            data.controlActEvent = PRPA_IN101103CA.CreateControlActEvent(
    ///                Guid.NewGuid(),
    ///                PRPA_IN101103CA.GetTriggerEvent(),
    ///                new MARC.Everest.Core.MR2009.MFMI_MT700751CA.Author(DateTime.Now),
    ///                new MARC.Everest.Core.MR2009.MFMI_MT700751CA.QueryByParameter<MARC.Everest.Core.MR2009.PRPA_MT101103CA.ParameterList>
    ///                    (Guid.NewGuid(),
    ///                    new MARC.Everest.Core.MR2009.PRPA_MT101103CA.ParameterList()
    ///                )
    ///            );
    ///
    ///            // Add the R1 format graphaides to the formatter. Lets us know how to translate the datatypes
    ///            xmlF.GraphAides.Add(new DatatypeFormatter());
    ///
    ///            try
    ///            {
    ///                // changes the size in memory dynamically and it has a memory location.
    ///                memstream = new MemoryStream();
    ///
    ///                // writer is going to be used as a holding area for the XML data, and when flushed,
    ///                // will be transferred to the MemoryStream(memstream). We go through this trouble 
    ///                // so that we can indent the XML code in the console and in the file.
    ///                writer = new XmlStateWriter(
    ///                    XmlWriter.Create(memstream, new XmlWriterSettings { Indent = true })
    ///                );
    ///
    ///                // Translate the message object, data, into XML and stores it in the XmlStateWriter(writer)
    ///                var result = xmlF.Graph(writer, data);
    ///
    ///                // Dumps the contents of the XML Writer buffer to the memory stream. 
    ///                writer.Flush();
    ///
    ///                // Declare file to write to. 
    ///                fs = new FileStream(@"C:\temp\test43.xml", FileMode.OpenOrCreate);
    ///
    ///                Console.WriteLine("XML\r\n");
    ///
    ///                //Set to false to disable validation. 
    ///                xmlF.ValidateConformance = false; 
    ///
    ///                // writes to Console
    ///                memstream.WriteTo(Console.OpenStandardOutput());
    ///
    ///                // writes to file.
    ///                memstream.WriteTo(fs);
    ///
    ///
    ///            }
    ///            catch (Exception)
    ///            {
    ///
    ///                throw;
    ///            }
    ///            finally
    ///            {
    ///
    ///                if (null != fs)
    ///                {
    ///                    Console.WriteLine("\r\nClosing File Stream now...");
    ///                    fs.Close();
    ///                    fs.Dispose();
    ///                }
    ///                if (null != writer)
    ///                {
    ///                    Console.WriteLine("Closing XML State Writer now...");
    ///                    writer.Close();
    ///                }
    ///                if (null != memstream)
    ///                {
    ///                    Console.WriteLine("Closing memory stream now...");
    ///                    memstream.Close();
    ///                    memstream.Dispose();
    ///                }
    ///                xmlF.Dispose();
    ///            }
    ///            Console.ReadKey(); 
    ///        } 
    ///    } 
    ///} 
    /// ]]>
    /// </code>
    /// </example>
    [Description("Formatter for XML ITS 1.0")]
#if WINDOWS_PHONE
    public class XmlIts1Formatter : IXmlStructureFormatter, ICodeDomStructureFormatter, IValidatingStructureFormatter, IDisposable
#else
    public class XmlIts1Formatter : IXmlStructureFormatter, ICloneable, ICodeDomStructureFormatter, IValidatingStructureFormatter, IDisposable
#endif
    {

        /// <summary>
        /// XSI
        /// </summary>
        public const string NS_XSI = "http://www.w3.org/2001/XMLSchema-instance";

        // A dictionary of root name maps that are used by the default Parse method
        private Dictionary<string, Type> s_rootNameMaps = new Dictionary<string, Type>();

        // Type name maps
        private Dictionary<string, Type> s_typeNameMaps = new Dictionary<string, Type>();

#if !WINDOWS_PHONE
        // A shared wait thread pool for creating datatypes
        private static WaitThreadPool s_threadPool = new WaitThreadPool(1); //WaitThreadPool.Current;
#endif
        // The code generator formatter
        private CodeGenFormatter m_codeGeneratorFormatter = new CodeGenFormatter();


        // A list of generated assemblies
        private List<Assembly> m_generatedAssemblies = new List<Assembly>(10);

        // The reflection formatter
        private ReflectFormatter m_reflectionFormatter = new ReflectFormatter();

        // Synchronization root
        private readonly object m_syncRoot = new object();
        // True when build types is blocking
        private bool m_isBuildTypesBlocking = false;

        #region Properties

        /// <summary>
        /// Gets or sets a value that indicates whether the formatter should
        /// format all required elements with nullFlavor of NI
        /// </summary>
        /// <example>
        /// <code lang="cs" title="Generating Required Elements Setting">
        /// <![CDATA[
        ///XmlWriter xw = null;
        ///
        ///try
        ///{
        ///
        ///    // Setup the formatter
        ///    var its1Formatter = new XmlIts1Formatter()
        ///    {
        ///        CreateRequiredElements = true
        ///    };
        ///    its1Formatter.GraphAides.Add(new DatatypeFormatter());
        ///
        ///    // Initialize the XmlWriter & State writer
        ///    xw = XmlWriter.Create("mydata.xml", new XmlWriterSettings() 
        ///{ Indent = true });
        /// 
        ///    // State writer should always be used
        ///    XmlStateWriter xsw = new XmlStateWriter(xw);
        ///
        ///    // Create an instance
        ///    REPC_IN000076CA instance = new REPC_IN000076CA(
        ///        Guid.NewGuid(),
        ///        DateTime.Now,
        ///        ResponseMode.Immediate,
        ///        REPC_IN000076CA.GetInteractionId(),
        ///        REPC_IN000076CA.GetProfileId(),
        ///        ProcessingID.Production,
        ///        AcknowledgementCondition.Always,
        ///        null,
        ///        null);
        ///    instance.controlActEvent = new MARC.Everest.RMIM.CA.R020402.MCAI_MT700210CA.ControlActEvent<MARC.Everest.RMIM.CA.R020402.REPC_MT220001CA.Document>();
        ///
        ///    // Format
        ///    var result = its1Formatter.Graph(xsw, instance);
        ///
        ///    // Flush the xml state writer
        ///    xsw.Flush();
        ///
        ///}
        ///finally
        ///{
        ///    if (xw != null)
        ///        xw.Close();
        ///}
        /// ]]>
        /// </code>
        /// <code lang="xml" title="Sample with CreateRequiredElements = false">
        /// <![CDATA[
        ///<REPC_IN000076CA ITSVersion="XML_1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3">
        ///  <id root="54CC5226-2875-4573-BCFC-114737D89438" />
        ///  <creationTime value="20111220222435.974-0500" />
        ///  <responseModeCode code="I" />
        ///  <versionCode code="V3-2008N" />
        ///  <interactionId root="2.16.840.1.113883.1.18" extension="REPC_IN000076CA" />
        ///  <profileId root="2.16.840.1.113883.2.20.2" extension="R02.04.02" />
        ///  <processingCode code="P" />
        ///  <processingModeCode code="T" />
        ///  <acceptAckCode code="AL" />
        ///  <controlActEvent classCode="CACT" moodCode="EVN">
        ///    <statusCode code="completed" />
        ///  </controlActEvent>
        ///</REPC_IN000076CA>
        /// ]]>
        /// </code>
        /// <code lang="xml" title="Sample with CreateRequiredElements = true">
        /// <![CDATA[
        ///<REPC_IN000076CA ITSVersion="XML_1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:hl7-org:v3">
        ///  <id root="504F61EC-A66E-43E0-ADB4-63D7B27AAE4E" />
        ///  <creationTime value="20111220222511.788-0500" />
        ///  <responseModeCode code="I" />
        ///  <versionCode code="V3-2008N" />
        ///  <interactionId root="2.16.840.1.113883.1.18" extension="REPC_IN000076CA" />
        ///  <profileId root="2.16.840.1.113883.2.20.2" extension="R02.04.02" />
        ///  <processingCode code="P" />
        ///  <processingModeCode code="T" />
        ///  <acceptAckCode code="AL" />
        ///  <controlActEvent classCode="CACT" moodCode="EVN">
        ///    <statusCode code="completed" />
        ///    <effectiveTime nullFlavor="NI" />
        ///    <reasonCode nullFlavor="NI" />
        ///    <languageCode nullFlavor="NI" />
        ///    <subjectOf1 xsi:nil="true" nullFlavor="NI" />
        ///  </controlActEvent>
        ///</REPC_IN000076CA>
        /// ]]>
        /// </code>
        /// </example>
        public bool CreateRequiredElements { get; set; }

        /// <summary>
        /// Gets or sets the formatting setting for this formatter instance.
        /// </summary>
        /// <example>
        /// <code lang="cs" title="Setting XML ITS 1.0 Formatter Settings">
        /// <![CDATA[
        /// // Create the formatter and setup the graph aides
        ///var formatter = new XmlIts1Formatter();
        ///formatter.GraphAides.Add(new DatatypeFormatter() { CompatibilityMode = DatatypeFormatterCompatibilityMode.ClinicalDocumentArchitecture });
        ///
        /// // Disable validation
        ///formatter.ValidateConformance = false;
        ///
        /// // Create settings
        ///formatter.Settings = SettingsType.UseReflectionFormat | SettingsType.AllowFlavorImposing;
        /// ]]>
        /// </code>
        /// </example>
        public SettingsType Settings { get; set; }

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a new instance of the Formatter class
        /// </summary>
        public XmlIts1Formatter ()
	    {
            this.ValidateConformance = true;
            this.CreateRequiredElements = false;
            GenerateInMemory = true;
            this.GraphAides = new List<IStructureFormatter>(4);
            //this.Settings = SettingsType.DefaultLegacy;
            #if WINDOWS_PHONE
            this.Settings = SettingsType.AllowFlavorImposing | SettingsType.AllowSupplierDomainImposing | SettingsType.AllowUpdateModeImposing;
            #else
            this.Settings = Environment.ProcessorCount > 1 ? SettingsType.DefaultMultiprocessor : SettingsType.DefaultUniprocessor;
            #if DEBUG
            System.Diagnostics.Trace.TraceInformation("{0}", this.Settings);
            #endif
            #endif
	    }

        /// <summary>
        /// Destroys the instance of the formatter class
        /// </summary>
        ~XmlIts1Formatter()
        {
            if (!m_isDisposed)
                this.Dispose();
        }
        #endregion

        #region IXmlStructureFormatter Members


        /// <summary>
        /// Graphs <paramref name="o"/> onto the <see cref="T:System.Xml.XmlWriter"/> <paramref name="s"/>
        /// </summary>
        /// <param name="s">The <see cref="T:System.Xml.XmlWriter"/> that should be used to graph the object</param>
        /// <param name="o">The <see cref="T:MARC.Everest.Interfaces.IGraphable"/> that should be graphed</param>
        /// <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterGraphResult"/> containing the results of the graph</returns>
        /// <remarks>
        /// <para>
        /// This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
        /// an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
        /// </para>
        /// <example>
        /// <code lang="cs" title="Using Everest as a Serializer Assistant">
        /// <![CDATA[
        /// StringWriter sw = new StringWriter();
        /// XmlWriter writer = XmlWriter.Create(sw);
        /// writer.WriteStartElement("hello", "urn:my-org");
        /// 
        /// Formatter f = new Formatter();
        /// f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
        /// f.ValidateConformance = false;
        /// f.Graph(writer, new MCCI_IN000002CA());
        /// 
        /// writer.WriteEndElement();
        /// writer.Close();
        /// Console.WriteLine(sw.ToString());
        /// 
        /// ]]>
        /// </code>
        /// outputs
        /// <code lang="xml" title="Output of example">
        /// <![CDATA[
        /// <hello xmlns="urn:my-org">
        ///     <MCCI_IN000002CA xmlns="urn:hl7-org:v3"/>
        /// </hello>
        /// ]]>
        /// </code>
        /// </example>
        /// <para>
        /// When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateWriter"/> as it 
        /// will allow the formatter to give additional location information when reporting issues.
        /// </para>
        /// </remarks>
        public IFormatterGraphResult Graph(XmlWriter s, IGraphable o)
        {
            ThrowIfDisposed();

            var resultContext = new XmlIts1FormatterGraphResult(ResultCode.Accepted, null);

            IGraphable context = null;
            // Clear out result cache
            if (s.WriteState == WriteState.Start || String.IsNullOrEmpty(s.ToString()) || o is IInteraction)
                context = o;

            if (!(s is XmlStateWriter))
                s = new XmlStateWriter(s);

            if (o == null)
                resultContext.Code = ResultCode.AcceptedNonConformant;
            else
            {
                GraphObject(s, o, o.GetType(), context, resultContext);
                resultContext.Code = CalculateResultCode(resultContext.Details);
            }

            return resultContext;
        }

        /// <summary>
        /// Set an appropriate result code
        /// </summary>
        private ResultCode CalculateResultCode(IEnumerable<IResultDetail> details)
        {
            // Set the acceptance code
            if (!ValidateConformance && details.Count() > 0)
                return ResultCode.AcceptedNonConformant;
            else
                return details.Count(d => d.Type == ResultDetailType.Error) > 0 ? ResultCode.Rejected :
                    details.Count(d => d.Type == ResultDetailType.Warning) > 0 ? ResultCode.AcceptedNonConformant :
                    ResultCode.Accepted;
        }



        /// <summary>
        /// Parse an object from <see cref="T:System.Xml.XmlReader"/> <paramref name="r"/>
        /// </summary>
        /// <param name="r">The <see cref="T:System.Xml.XmlReader"/> to parse an object from</param>
        /// <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the formatted instance</returns>
        /// <remarks>
        /// <para>
        /// This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
        /// an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
        /// </para>
        /// <example>
        /// <code lang="cs" title="Using Everest as a Serializer Assistant">
        /// <![CDATA[
        /// StringWriter sw = new StringWriter("<hello><MCCI_IN000002CA xmlns=\"urn:hl7-org:v3\"/></hello>");
        /// XmlReader reader = XmlReader.Create(sw);
        /// reader.Read(); // Read <hello>
        /// 
        /// Formatter f = new Formatter();
        /// f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
        /// f.ValidateConformance = false;
        /// var result = f.Parse(reader);
        /// 
        /// reader.Read();
        /// reader.Close();
        /// Console.WriteLine(result.Code); 
        /// 
        /// ]]>
        /// </code>
        /// </example>
        /// <para>
        /// When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateReader"/> as it 
        /// will allow the formatter to give additional location information when reporting issues.
        /// </para>
        /// </remarks>
        public IFormatterParseResult Parse(XmlReader r)
        {
            ThrowIfDisposed();

            // Clear existing results
            XmlIts1FormatterParseResult resultContext = new XmlIts1FormatterParseResult(ResultCode.Accepted, null);

            if (!(r is XmlStateReader))
                r = new XmlStateReader(r);

            // Initial state
            if (r.ReadState == ReadState.Initial)
                while (r.NodeType != XmlNodeType.Element)
                    r.Read();

            // Detect if we can parse this...
            //if (r.NamespaceURI != "urn:hl7-org:v3")
            //    throw new XmlException(string.Format("Can't parse '{0}' in namespace '{1}'. The data does not appear to be an HL7v3 instance", r.LocalName, r.NamespaceURI), null);

            // Do we have a formatter for the object
            Type mappedType;

            // Predicate will find the mapped type for us
            Predicate<Type> typeComparator = delegate(Type t)
            {
                object[] structureAttribute = t.GetCustomAttributes(typeof(StructureAttribute), true);
                if (structureAttribute.Length > 0 && ((structureAttribute[0] as StructureAttribute).StructureType == StructureAttribute.StructureAttributeType.Interaction || (structureAttribute[0] as StructureAttribute).IsEntryPoint)
                    && (structureAttribute[0] as StructureAttribute).Name == r.LocalName && (structureAttribute[0] as StructureAttribute).NamespaceUri == r.NamespaceURI)
                    return true;
                return false;
            };

            // Try to find the value if it doesn't succeed, try to build it and try to find it again
            for (int i = 0; i < 2 && resultContext.Structure == null; i++)
            {
                if (s_rootNameMaps.TryGetValue(r.LocalName, out mappedType)) // Try to get a root name map
                {
                    resultContext.Structure = ParseObject(r, mappedType, mappedType, resultContext);
                    resultContext.Code = CalculateResultCode(resultContext.Details);
                    return resultContext;
                }
                else if (i == 0) // Try to build the cache for this root name
                {
                    // Last attempt, try to find a type in the app domain that we can scan!
                    Predicate<Assembly> asmPredicate = delegate(Assembly a)
                    {
                        try
                        {
#if WINDOWS_PHONE
                            return a.GetTypes().Exists(typeComparator);
#else
                            return Array.Find<Type>(a.GetTypes(), typeComparator) != null;
#endif
                        }
                        catch
                        {
                            return false;
                        }
                    };

#if WINDOWS_PHONE
                    Assembly asm = AppDomain.CurrentDomain.GetAssemblies().Find(asmPredicate);
#else
                    Assembly asm = Array.Find<Assembly>(AppDomain.CurrentDomain.GetAssemblies(), asmPredicate);
#endif
                    if (asm == null) // Couldn't find assembly... ditch
                        break;
                    else
                        return Parse(r, asm); //BuildCache(new Type[] { Array.Find<Type>(asm.GetTypes(), typeComparator) });
                }
                //i++;
            }

            resultContext.AddResultDetail(new ResultDetail(ResultDetailType.Error, String.Format("Could not find a type to de-serialize '{0}' into", r.Name), r.ToString(), null));
            resultContext.Code = ResultCode.Rejected;
            return resultContext;
        }

        /// <summary>
        /// Parse an object from <see cref="T:System.Xml.XmlReader"/> <paramref name="r"/> using the type
        /// hint <param name="t"/>
        /// </summary>
        /// <param name="r">The <see cref="T:System.Xml.XmlReader"/> to parse an object from</param>
        /// <param name="t">The type hint to parse the object</param>
        /// <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the formatted instance</returns>
        /// <remarks>
        /// <para>
        /// This particular overload of the Graph method can be used to graph objects into a <see cref="T:System.Xml.XmlWriter"/> and can provide
        /// an opportunity to use Everest as an assistant (or XmlSerializerSurrogate) for more complex systems like WCF.
        /// </para>
        /// <example>
        /// <code lang="cs" title="Using Everest as a Serializer Assistant">
        /// <![CDATA[
        /// StringWriter sw = new StringWriter("<hello><MCCI_IN000002CA xmlns=\"urn:hl7-org:v3\"/></hello>");
        /// XmlReader reader = XmlReader.Create(sw);
        /// reader.Read(); // Read <hello>
        /// 
        /// Formatter f = new Formatter();
        /// f.GraphAides.Add(typeof(MARC.Everest.Formatters.XML.DataTypes.R1.Formatter));
        /// f.ValidateConformance = false;
        /// var result = f.Parse(reader, typeof(MCCI_IN000002CA));
        /// 
        /// reader.Read();
        /// reader.Close();
        /// Console.WriteLine(result.Code); 
        /// 
        /// ]]>
        /// </code>
        /// </example>
        /// <para>
        /// When using this method, it is recommended that you pass a <see cref="T:MARC.Everest.Xml.XmlStateReader"/> as it 
        /// will allow the formatter to give additional location information when reporting issues.
        /// </para>
        /// </remarks>
        public IFormatterParseResult Parse(XmlReader r, Type t)
        {
            if (!(r is XmlStateReader))
                r = new XmlStateReader(r);

            // Initial state
            if (r.ReadState == ReadState.Initial)
                while (r.NodeType != XmlNodeType.Element)
                    r.Read();

            // Detect if we can parse this...
            if (r.NamespaceURI != "urn:hl7-org:v3")
                throw new XmlException(string.Format("Can't parse '{0}' in namespace '{1}'. The data does not appear to be an HL7v3 instance", r.LocalName, r.NamespaceURI), null);

            var resultContext = new XmlIts1FormatterParseResult(ResultCode.Accepted, null);
            resultContext.Structure = ParseObject(r, t, null, resultContext);
            return resultContext;
        }

        #endregion

        #region IStructureFormatter Members

        /// <summary>
        /// Gets or sets a list of aide formatters that can be instantiated 
        /// to assist in the formatting of this instance.
        /// </summary>
        public List<IStructureFormatter> GraphAides { get; set;}

        /// <summary>
        /// Gets or sets the host formatter of this structure formatter
        /// </summary>
        public IStructureFormatter Host { get; set; }

        /// <summary>
        /// Returns a list of structures that this formatter can "handle"
        /// </summary>
        public List<string> HandleStructure
        {
            get { return new List<string>( new string[] { "*" } ); }
        }


        /// <summary>
        /// Graphs object <paramref name="o"/> onto stream <paramref name="s"/>
        /// </summary>
        /// <param name="s">The stream to which <paramref name="o"/> is to be graphed</param>
        /// <param name="o">The object to be graphed</param>
        /// <returns>A <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterGraphResult"/> structure contianing the 
        /// results of formatting</returns>
        /// <seealso cref="F:Graph(System.Xml.XmlWriter,MARC.Everest.Interfaces.IGraphable)"/>
        public IFormatterGraphResult Graph(Stream s, IGraphable o)
        {
            ThrowIfDisposed();

            XmlWriter xwtr = XmlWriter.Create(s);
            XmlStateWriter xw = new XmlStateWriter(xwtr);

            if (o == null)
                return new XmlIts1FormatterGraphResult(ResultCode.AcceptedNonConformant, null);


            //TODO: Length will never be less than 0 so the logic should be > 0 instead of != 0.
            bool needsRoot = o.GetType().GetCustomAttributes(typeof(InteractionAttribute), true).Length == 0;
            if (needsRoot)
            {
                object[] sa = o.GetType().GetCustomAttributes(typeof(StructureAttribute), true);
                needsRoot = sa.Length == 0 || !(sa[0] as StructureAttribute).IsEntryPoint;
                if (needsRoot)
                {
                    xw.WriteStartElement(o.GetType().FullName, "urn:hl7-org:v3");
                    xw.WriteAttributeString("xmlns", "xsi", null, XmlIts1Formatter.NS_XSI);

                }

            }

            // Determine if this is not an interaction
            var result = Graph(xw, o);

            if (needsRoot)
                xw.WriteEndElement();

            xw.Flush();
            return result;
        }


        /// <summary>
        /// Removes an XSI type from the registry
        /// </summary>
        public void RemoveXSITypeName(string xsiTypeName)
        {
            this.s_typeNameMaps.Remove(xsiTypeName);
        }

        /// <summary>
        /// Registers a specific xsi:type name for the specified type
        /// </summary>
        public void RegisterXSITypeName(string xsiTypeName, Type type)
        {
            if (this.s_typeNameMaps.ContainsKey(xsiTypeName))
                throw new DuplicateItemException(String.Format("'{0}' is already registered to another type", xsiTypeName));
            this.s_typeNameMaps.Add(xsiTypeName, type);
        }

        /// <summary>
        /// Parse an object from <paramref name="s"/>
        /// </summary>
        /// <param name="s">The stream from which to parse an object</param>
        /// <returns>An <see cref="T:MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> structure containing the parsed information</returns>
        /// <remarks>
        /// <para>
        /// The parse method will attempt to search any of the already known types (ie: types already learned) for a serialization start point. If
        /// one is not found, the method will search the current AppDomain to find <see cref="T:MARC.Everest.Interfaces.IGraphable"/> classes
        /// which can be used to interpret the data within the stream. For this, the root element is used to find 
        /// which of the types can start serialization.
        /// </para>
        /// <para>
        /// While this method will work fine when dealing with one RMIM assembly, it is recommended that you use the 
        /// <seealso cref="F:Graph(System.IO.Stream,System.Reflection.Assembly)"/> method when more than one RMIM assembly
        /// is loaded in memory.
        /// </para>
        /// </remarks>
        public IFormatterParseResult Parse(Stream s)
        {
            XmlReader rdr = new XmlStateReader(XmlReader.Create(s));
            try
            {
                return Parse(rdr); // Parse the object using the XML Reader
            }
            finally
            {
                rdr.Close();
            }
        }

        #endregion

        #region ICloneable Members

        /// <summary>
        /// Clones this formatter 
        /// </summary>
        public object Clone()
        {
            ThrowIfDisposed();

            return this.MemberwiseClone();
        }

        #endregion

        #region ICodeDomStructureFormatter Members

        /// <summary>
        /// Sets a value that indicates whether this formatter should generate
        /// assemblies in memory or on disk
        /// </summary>
        public bool GenerateInMemory { set; private get; }

        /// <summary>
        /// Gets a list of assemblies that have been generated by this formatter
        /// </summary>
        public Assembly[] GeneratedAssemblies { 
            get
            {
                return this.m_generatedAssemblies.ToArray();
            }
        }

        /// <summary>
        /// Parses an object from <paramref name="s"/> using <paramref name="a"/> to locate
        /// a suitable class definition to populate.
        /// </summary>
        /// <param name="s">The stream from which to parse the object</param>
        /// <param name="a"><paramref name="s"/> in object form</param>
        /// <returns>A <see cref="MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the results of the parse</returns>
        /// <remarks>
        /// <para>This method differs from the <seealso cref="F:Parse(System.IO.Stream)"/> method in that it
        /// will only look within the specified assembly for a suitable class to populate.</para>
        /// <para>
        /// This method will not check the current learned type repository for a class to serialize (ie: it will always 
        /// check the assembly regardless of what has been formatted prior)
        /// </para>
        /// </remarks>
        public IFormatterParseResult Parse(Stream s, Assembly a)
        {
            return Parse(new XmlStateReader(XmlReader.Create(s)), a);
        }

                /// <summary>
        /// Parses an object from <paramref name="r"/> using <paramref name="a"/> to locate
        /// a suitable class definition to populate.
        /// </summary>
        /// <param name="r">The <see cref="T:System.Xml.XmlReader"/> from which to parse the object</param>
        /// <param name="a"><paramref name="s"/> in object form</param>
        /// <returns>A <see cref="MARC.Everest.Formatters.XML.ITS1.Its1FormatterParseResult"/> containing the results of the parse</returns>
        /// <remarks>
        /// <para>This method differs from the <seealso cref="F:Parse(System.Xml.XmlReader)"/> method in that it
        /// will only look within the specified assembly for a suitable class to populate.</para>
        /// <para>
        /// This method will not check the current learned type repository for a class to serialize (ie: it will always 
        /// check the assembly regardless of what has been formatted prior)
        /// </para>
        /// </remarks>
        public IFormatterParseResult Parse(XmlReader r, Assembly a)
        {
            ThrowIfDisposed();

            var resultContext = new XmlIts1FormatterParseResult(ResultCode.Accepted, null);

            if (!(r is XmlStateReader))
                r = new XmlStateReader(r);

            // Initial state
            if (r.ReadState == ReadState.Initial)
                while (r.NodeType != XmlNodeType.Element)
                    r.Read();

            // Detect if we can parse this...
            //if (r.NamespaceURI != "urn:hl7-org:v3")
            //    throw new XmlException(string.Format("Can't parse '{0}' in namespace '{1}'. The data does not appear to be an HL7v3 instance", r.LocalName, r.NamespaceURI), null);

            // Predicate will find the mapped type for us
            Predicate<Type> typeComparator = delegate(Type t)
            {
                object[] structureAttribute = t.GetCustomAttributes(typeof(StructureAttribute), true);
                if (structureAttribute.Length > 0 && ((structureAttribute[0] as StructureAttribute).StructureType == StructureAttribute.StructureAttributeType.Interaction || (structureAttribute[0] as StructureAttribute).IsEntryPoint)
                    && (structureAttribute[0] as StructureAttribute).Name == r.LocalName && (structureAttribute[0] as StructureAttribute).NamespaceUri == r.NamespaceURI)
                    return true;
                return false;
            };

            // Try to find the value if it doesn't succeed, try to build it and try to find it again
#if WINDOWS_PHONE
            Type fType = a.GetTypes().Find(typeComparator);
#else
            Type fType = Array.Find<Type>(a.GetTypes(), typeComparator);
#endif

            // Found the type
            if (fType != null)
                resultContext.Structure = this.ParseObject(r, fType, fType, resultContext);
            else
                resultContext.AddResultDetail(
                        new ResultDetail(ResultDetailType.Error, String.Format("Could not find a type to de-serialize '{0}' into", r.Name), r.ToString(), null)
                    );

            // Set the acceptance code
            resultContext.Code = CalculateResultCode(resultContext.Details);
            return resultContext;
        }


        /// <summary>
        /// Builds a type cache for the specified list of types
        /// </summary>
        public void BuildCache(Type[] t)
        {
#if WINDOWS_PHONE
            throw new NotSupportedException("BuildCache method is not supported in Everest for Windows Phone");
#else
            ThrowIfDisposed();

            // Ensure we block
            lock(m_syncRoot)
            {
                while(m_isBuildTypesBlocking)
                    Monitor.Wait(m_syncRoot);
                m_isBuildTypesBlocking = true;
            }

            // Generate assembly
            try
            {
                var asm = m_codeGeneratorFormatter.CreateFormatterAssembly(t, this.GraphAides, (this.Settings & SettingsType.EnableDeepLearning) == SettingsType.EnableDeepLearning || !GenerateInMemory);

                this.AddRootNameMaps(t);

                if(asm != null)
                    m_generatedAssemblies.Add(asm);
            }
            finally
            {
                // Release the block
                lock (m_syncRoot)
                {
                    m_isBuildTypesBlocking = false;
                    Monitor.Pulse(m_syncRoot);
                }
            }
#endif
        }

        
        #endregion

        #region IValidatingStructureFormatter Members

        /// <summary>
        /// Gets or sets a value that indicates whether this formatter will validate conformance
        /// </summary>
        /// <remarks>When set to true, the formatter will not produce output when
        /// an invalid message is encountered</remarks>
        public bool ValidateConformance { get; set; }

        #endregion

        #region Utility Functions

        /// <summary>
        /// Get formatter from xsi type
        /// </summary>
        /// <param name="p"></param>
        /// <returns></returns>
        internal IXmlStructureFormatter GetAdjustedFormatter(string xsiType)
        {

            // Formatter type
            string xsiTypeRoot = xsiType;

            // Generic 
            if (!String.IsNullOrEmpty(xsiTypeRoot) && xsiTypeRoot.Contains("_"))
                xsiTypeRoot = xsiTypeRoot.Substring(0, xsiTypeRoot.IndexOf("_"));

            // Get the type
            if (String.IsNullOrEmpty(xsiType))
                return null;

            var retVal = this.GraphAides.Find(t => t.HandleStructure.Contains(xsiTypeRoot)); 
            return retVal as IXmlStructureFormatter;
        }

        ///// <summary>
        ///// Creates graph aides in a more useable form
        ///// </summary>
        //private void CreateGraphAides()
        //{
        //    if(this.m_graphAides.Count != this.GraphAides.Count)
        //    {
        //        this.m_graphAides.Clear();
        //        foreach(Type t in this.GraphAides)
        //            this.m_graphAides.Add(t.Assembly.CreateInstance(t.FullName) as IXmlStructureFormatter);
        //    }
        //}

        /// <summary>
        /// Utility function for helper formatters
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void WriteElementUtil(XmlWriter s, string namespaceUri, string elementName, IGraphable g, Type propType, IGraphable context, XmlIts1FormatterGraphResult resultContext)
        {
            ThrowIfDisposed();

            
            // Graph is nothing
            if (g == null)
                return;

            // Normalize
            if (g is INormalizable)
                g = (g as INormalizable).Normalize();

            // Write start of element
            s.WriteStartElement(elementName, namespaceUri);
            
            // JF: Output XSI:Type
            if (!g.GetType().Equals(propType) )
            {
                // TODO: This may cause issue when assigning a QSET to an R1 or
                //       SXPR to R2 instance as the XSI:TYPE will be inappropriately
                //       assigned.

                string xsiType = String.Empty;
                if (typeof(ANY).IsAssignableFrom(g.GetType()))
                {
                    xsiType += s.LookupPrefix("urn:hl7-org:v3");
                    if (!String.IsNullOrEmpty(xsiType))
                        xsiType += ":";
                    xsiType += Util.CreateXSITypeName(g.GetType());
                }
                else if (propType != null && g.GetType().Assembly.FullName != propType.Assembly.FullName)
                {
                    string typeName = this.CreateXSITypeName(g.GetType(), context != null ? context.GetType() : null, s as IXmlNamespaceResolver);

                    // If there is no different then don't output
                    if (typeName != String.Format("{0}.{1}", this.GetModelName(propType), this.GetStructureName(propType)))
                    {

                        lock (this.m_syncRoot)
                            if (!this.s_typeNameMaps.ContainsKey(typeName))
                                this.RegisterXSITypeName(typeName, g.GetType());
                    }
                    xsiType = typeName;
                }
                if(!String.IsNullOrEmpty(xsiType))
                    s.WriteAttributeString("xsi", "type", XmlIts1Formatter.NS_XSI, xsiType);

                //string xsdTypeName = String.Empty;
                //object[] sa = g.GetType().GetCustomAttributes(typeof(StructureAttribute), false);
                //if (sa.Length > 0 && (sa[0] as StructureAttribute).StructureType == StructureAttribute.StructureAttributeType.DataType)
                //    s.WriteAttributeString("xsi", "type", null, (sa[0] as StructureAttribute).Name);
            }

            // Result code of the
            GraphObject(s, g, g.GetType(), context, resultContext);
            s.WriteEndElement();
        }

        /// <summary>
        /// Write the nullflavor
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual void WriteNullFlavorUtil(XmlWriter s, IGraphable nullFlavor)
        {
            ThrowIfDisposed();

            if((this.Settings & SettingsType.SuppressXsiNil) == 0)
                s.WriteAttributeString("xsi", "nil", XmlIts1Formatter.NS_XSI, "true");
            s.WriteAttributeString("nullFlavor", Util.ToWireFormat(nullFlavor));
        }

        /// <summary>
        /// Adds <paramref name="asm"/> to the cache of generated
        /// formatter assemblies to be used in serialization.
        /// </summary>
        /// <param name="asm">The assembly to add to the formatter helper cache</param>
        /// <example>
        /// <code lang="cs" title="Adding an assembly to the cache of generated assemblies">
        /// <![CDATA[

        /// // Create the formatter and setup the graph aides
        ///var formatter = new XmlIts1Formatter();
        ///formatter.GraphAides.Add(new DatatypeFormatter() { 
        ///    CompatibilityMode = DatatypeFormatterCompatibilityMode.Universal 
        ///});
        ///
        /// // Disable validation
        ///formatter.ValidateConformance = false;
        ///
        /// // Load the assembly and instruct the formatter to use the pre-generated
        /// // code in the assembly
        ///formatter.AddFormatterAssembly(
        /// Assembly.LoadFile(@"C:\cache\MARC.Everest.RMIM.UV.NE2008.XML.ITS1.dll")
        ///);
        /// ]]>
        /// </code>
        /// </example>
        public void AddFormatterAssembly(Assembly asm)
        {
            ThrowIfDisposed();
            this.m_codeGeneratorFormatter.AddFormatterAssembly(asm);
        }

        /// <summary>
        /// Adds a cached formatter assembly to this type
        /// </summary>
        public void AddRootNameMaps(Type[] types)
        {
            // Scan for all types
            foreach (Type t in types)
                if (t.GetInterface(typeof(IGraphable).FullName, false) != null)
                {
                    //Formatters.Add(tf); // Add formatter if it exists
                    object[] structureAttribute = t.GetCustomAttributes(typeof(StructureAttribute), true);
                    bool isInteraction = t.GetCustomAttributes(typeof(InteractionAttribute), true).Length > 0; // Remain compatible with the GraphObject logic
                    StructureAttribute sa = structureAttribute[0] as StructureAttribute;
                    bool isEntryPoint = sa.IsEntryPoint;
                    lock (s_rootNameMaps)
                    {
                        if(!s_rootNameMaps.ContainsKey(sa.Name) && (isEntryPoint || isInteraction))
                            s_rootNameMaps.Add(sa.Name, t);
                        else if(!s_rootNameMaps.ContainsKey(t.FullName))
                            s_rootNameMaps.Add(t.FullName, t);
                    }
                }
        }

        /// <summary>
        /// Parse the object
        /// </summary>
        /// <param name="r">The reader to read from</param>
        /// <param name="useType">The type to use to parse</param>
        /// <param name="interactionContext">The current interaction being parsed</param>
        /// <returns>The parsed object</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "r"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual IGraphable ParseObject(XmlReader r, Type useType, Type interactionContext, XmlIts1FormatterParseResult resultContext)
        {
            ThrowIfDisposed();


            // Find a helper
            string typeName = GetStructureName(useType);

            IXmlStructureFormatter ixsf = null;
            
            // xsi type? - We want to adjust the type based on this value
            try
            {
                string xsiType = r.GetAttribute("type", NS_XSI);
                // Is this model / type registered somewhere ?
                if ((this.Settings & SettingsType.AlwaysCheckForOverrides) != 0 && xsiType == null &&
                    !typeof(ANY).IsAssignableFrom(useType))
                    xsiType = this.CreateXSITypeName(useType, interactionContext, r as IXmlNamespaceResolver);

                if (xsiType != null)
                {
                    if (useType.IsInterface || typeof(ANY).IsAssignableFrom(useType)) // HACK: We don't override the use type for ANY derivatives as some types are special and require special typing
                        ixsf = this.GetAdjustedFormatter(xsiType); //Util.ParseXSITypeName(r.GetAttribute("type", NS_XSI));
                    else
                        useType = this.ParseXSITypeName(xsiType, r as IXmlNamespaceResolver);
                }
                else
                    ixsf = (IXmlStructureFormatter)this.GraphAides.Find(t => t.HandleStructure.Contains(typeName));
            }
            catch (Exception e)
            {
                resultContext.AddResultDetail(new ResultDetail(ResultDetailType.Error, e.Message, r.ToString(), e));
            }

            string currentPath = r is XmlStateReader ? (r as XmlStateReader).CurrentPath : r.Name;
            // Does a helper have it?
            if (ixsf != null)
            {
                ixsf.Host = this;
                var aideResult = ixsf.Parse(r, useType);
                resultContext.AddResultDetail(aideResult.Details);
                return aideResult.Structure;
            }

#if WINDOWS_PHONE
            ITypeFormatter formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            if (formatter == null)
                formatter = new ReflectFormatter();
#else
            ITypeFormatter formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            // Is there a formatter and if there is not a formatter 
            // can we create one?
            if (formatter == null && (Settings & SettingsType.UseGeneratorFormat) == SettingsType.UseGeneratorFormat)
                s_threadPool.QueueUserWorkItem((WaitCallback)delegate(object state)
                {
                    BuildCache(new Type[] { (Type)state });
                }, useType);
            // If there is no connector can we use reflection?
            if (formatter == null && (Settings & SettingsType.UseReflectionFormat) == SettingsType.UseReflectionFormat)
                formatter = new ReflectFormatter();
            else if (formatter == null && (Settings & SettingsType.UseGeneratorFormat) == SettingsType.UseGeneratorFormat)
            {
                s_threadPool.WaitOne();
                formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            }
#endif
            if (formatter == null)
                throw new InvalidOperationException(string.Format("Couldn't format '{0}' at {1}, verify formatter settings", useType.FullName, r.ToString()));

            // Parse using the formatter
            formatter.Host = this;

            // Parse the object
            IGraphable result = (IGraphable)formatter.Parse(r, useType, interactionContext, resultContext);

            IResultDetail[] details = null;
            if (details != null && result == null || ValidateConformance && (!formatter.Validate(result, currentPath, out details)))
                resultContext.AddResultDetail(details.Length > 0 ? details : new IResultDetail[] { new ResultDetail(ValidateConformance ? ResultDetailType.Error : ResultDetailType.Warning, String.Format("Couldn't parse type '{0}'", useType.ToString()), currentPath) });

            
            return result;
        }

        /// <summary>
        /// Parse XSI type name
        /// </summary>
        public virtual Type ParseXSITypeName(string xsiTypeName)
        {
            return this.ParseXSITypeName(xsiTypeName, null);
        }

        /// <summary>
        /// Parse an xsi:type name
        /// </summary>
        private Type ParseXSITypeName(string xsiTypeName, IXmlNamespaceResolver namespaceResolver)
        {
            // Is there an XSITypeName map that already exists for this type?
            Type retVal = null;

            if (this.s_typeNameMaps.TryGetValue(xsiTypeName, out retVal))
                return retVal;

            // NS Prefix?
            String[] nsTokens = xsiTypeName.Split(':');
            string namespaceUri = "urn:hl7-org:v3";
            if (nsTokens.Length == 2)
            {
                xsiTypeName = nsTokens[1];
                namespaceUri = namespaceResolver.LookupNamespace(nsTokens[0]);
            }

            // Step one, tokenize the parts based on . separator
            String[] tokens = null;
            if(xsiTypeName.Contains("."))
                tokens = new String[] {
                    xsiTypeName.Substring(0, xsiTypeName.LastIndexOf(".") ),
                    xsiTypeName.Substring(xsiTypeName.LastIndexOf(".") + 1)
                };
            else
                tokens = new string[] { 
                    null,
                    xsiTypeName
                };

            // Is the first part an interaction?
            if (tokens.Length == 3)
            {
                // TODO: Predicate will find the mapped type for us
                // TODO: This happens for generics
                throw new NotImplementedException();
            }
            else if (tokens.Length == 2)
            {
                // Find the type that has the specified name and model
                String modelName = tokens[0], structureName = tokens[1];

                Predicate<Type> typeComparator = delegate(Type t)
                {
                    object[] structureAttribute = t.GetCustomAttributes(typeof(StructureAttribute), true);
                    if (structureAttribute.Length > 0 && ((StructureAttribute)structureAttribute[0]).Name == structureName &&
                        (((StructureAttribute)structureAttribute[0]).Model) == modelName &&
                        (((StructureAttribute)structureAttribute[0]).NamespaceUri == namespaceUri))
                        return true;
                    return false;
                };

                // Search for a type that matches
#if WINDOWS_PHONE
                Assembly candidateAssembly = AppDomain.CurrentDomain.GetAssemblies().Find(a => { try { return a.GetTypes().Exists(typeComparator); } catch { return false; } });
                retVal = candidateAssembly.GetTypes().Find(typeComparator);
#else
                Assembly candidateAssembly = Array.Find(AppDomain.CurrentDomain.GetAssemblies(), a => { try { return Array.Exists(a.GetTypes(), typeComparator); } catch { return false; } });
                retVal = Array.Find(candidateAssembly.GetTypes(), typeComparator);
#endif
                lock (this.m_syncRoot)
                    if (!this.s_typeNameMaps.ContainsKey(xsiTypeName))
                        this.RegisterXSITypeName(xsiTypeName, retVal);
            }
            else
                throw new ArgumentException("xsi:type cannot be auto-parsed. Please register it using RegisterXSITypeName");
            return retVal;
        }

        /// <summary>
        /// Creates an XSI:TYPE attribute that is friendly for RMIM structures
        /// </summary>
        public virtual string CreateXSITypeName(Type type)
        {
            return this.CreateXSITypeName(type, null, null);
        }

        /// <summary>
        /// Creates an XSI:TYPE attribute that is friendly for RMIM structures
        /// </summary>
        private string CreateXSITypeName(Type type, Type interactionContextType, IXmlNamespaceResolver namespaceResolver)
        {

            StringBuilder xsiType = new StringBuilder();

            // Scan the registered xsi:types first before creating a type
            lock(this.m_syncRoot)
                foreach (var itm in this.s_typeNameMaps)
                    if (itm.Value == type)
                        return itm.Key;

            // First, does the type acutally have a model name?
            Object[] saList = type.GetCustomAttributes(typeof(StructureAttribute), true);
            if (saList.Length == 0)
                xsiType.Append(type.FullName);
            else
            {
                StructureAttribute sa = saList[0] as StructureAttribute;
                
                // Namespace prefix?
                if (!String.IsNullOrEmpty(sa.NamespaceUri) && namespaceResolver != null)
                {
                    string prefix = namespaceResolver.LookupPrefix(sa.NamespaceUri);
                    if (!String.IsNullOrEmpty(prefix))
                        xsiType.AppendFormat("{0}:", prefix);
                }
                // Is the type generic?
                if (type.IsGenericType) // yes, then first we output the interaction 
                {
                    if (interactionContextType == null)
                        throw new FormatterException("Cannot emit xsi:type when no interaction context is provided!");
                    Object[] inSaList = interactionContextType.GetCustomAttributes(typeof(StructureAttribute), true);
                    if (inSaList.Length == 0)
                        throw new FormatterException("Invalid interaction context. Interaction context type must carry a StructureAttribute");
                    xsiType.AppendFormat("{0}.", (inSaList[0] as StructureAttribute).Name);
                }

                // Output the model and class name
                if(sa.Model != null)
                    xsiType.AppendFormat("{0}.{1}", sa.Model, sa.Name);
                else
                    xsiType.Append(sa.Name);
            }

            return xsiType.ToString();
        }


        /// <summary>
        /// Graph object onto xml writer
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider", MessageId = "System.String.Format(System.String,System.Object)"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "o"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "s")]
        protected virtual void GraphObject(XmlWriter s, IGraphable o, Type useType, IGraphable context, XmlIts1FormatterGraphResult resultContext)
        {

            // Find the HL7 alias for the type and build the cache for the type
            string typeName = GetStructureName(useType);

            // Find a helper
            IXmlStructureFormatter ixsf = (IXmlStructureFormatter)this.GraphAides.Find(t => t.HandleStructure.Contains(typeName));

            // Does the helper graph aide have a handler?
            if (ixsf != null)
            {
                ixsf.Host = this;
                var rv = ixsf.Graph(s, o);

                resultContext.AddResultDetail(rv.Details);

                return;
            }

#if WINDOWS_PHONE
            ITypeFormatter formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            if (formatter == null)
                formatter = new ReflectFormatter();
#else
            ITypeFormatter formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            // Is there a formatter and if there is not a formatter 
            // can we create one?
            if (formatter == null && (Settings & SettingsType.UseGeneratorFormat) == SettingsType.UseGeneratorFormat)
                s_threadPool.QueueUserWorkItem((WaitCallback)delegate(object state)
                {
                    BuildCache(new Type[] { (Type)state });
                }, useType);
            // If there is no connector can we use reflection?
            if (formatter == null && (Settings & SettingsType.UseReflectionFormat) == SettingsType.UseReflectionFormat)
                formatter = new ReflectFormatter();
            else if (formatter == null && (Settings & SettingsType.UseGeneratorFormat) == SettingsType.UseGeneratorFormat)
            {
                s_threadPool.WaitOne();
                formatter = m_codeGeneratorFormatter.GetFormatter(useType);
            }
#endif
            if(formatter == null)
                throw new InvalidOperationException(string.Format("Couldn't format '{0}' at {1}, verify formatter settings!", useType.FullName, s.ToString()));

            // Validate the instance
            formatter.Host = this;
            
            // Graph using helper
            formatter.Graph(s, o, context, resultContext);

        }

        /// <summary>
        /// Validation helper
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [Browsable(false)]
        public void ValidateHelper(XmlWriter s, IGraphable o, ITypeFormatter formatter, XmlIts1FormatterGraphResult resultContext)
        {
            IResultDetail[] details = null;

            if (ValidateConformance && (!formatter.Validate(o, s.ToString(), out details)))
                resultContext.AddResultDetail(details.Length > 0 ? details : new IResultDetail[] { new DatatypeValidationResultDetail(ValidateConformance ? ResultDetailType.Error : ResultDetailType.Warning, o.GetType().ToString(), s.ToString()) });
        }

        /// <summary>
        /// Gets structure name
        /// </summary>
        private string GetModelName(Type useType)
        {
            // Already built, so we can forgo checking

            // Create graph aides
            //CreateGraphAides();

            // Get the structure attribute and return the type name
            object[] structureAttribute = useType.GetCustomAttributes(typeof(StructureAttribute), true);
            string typeName = useType.Namespace;
            if (structureAttribute.Length > 0)
                typeName = (structureAttribute[0] as StructureAttribute).Model;

            return typeName;
        }
        /// <summary>
        /// Gets structure name
        /// </summary>
        private string GetStructureName(Type useType)
        {
            // Already built, so we can forgo checking
#if !WINDOWS_PHONE
            if (m_codeGeneratorFormatter.GetFormatter(useType) != null)
                return useType.Name;
#endif

            // Create graph aides
            //CreateGraphAides();

            // Get the structure attribute and return the type name
            object[] structureAttribute = useType.GetCustomAttributes(typeof(StructureAttribute), true);
            string typeName = useType.Name;
            if (structureAttribute.Length > 0)
                typeName = (structureAttribute[0] as StructureAttribute).Name;

            return typeName;
        }
        #endregion

        #region IDisposable Members

        // Disposed
        private bool m_isDisposed = false;
        
        /// <summary>
        /// Throw an exception if the object is disposed
        /// </summary>
        protected void ThrowIfDisposed()
        {
            if (m_isDisposed)
                throw new ObjectDisposedException(this.GetType().FullName);
        }

        /// <summary>
        /// Dispose this object
        /// </summary>
        public void Dispose()
        {
            
            if (!this.m_isDisposed)
            {
                this.s_typeNameMaps.Clear();
                this.s_typeNameMaps = null;

                this.m_isDisposed = true;
                
            }

        }

        #endregion
    }

    
}
