<?xml version="1.0" encoding="UTF-8"?><xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:mif="urn:hl7-org:v3/mif" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">  <xsl:template name="processForAnnotations">    <xsl:param name="sourceNodes"/>    <xsl:param name="pickUpProperties" select="'F'"/>    <xsl:variable name="srceSeries">      <xsl:call-template name="buildAnnotationSeries">        <xsl:with-param name="sourceNodes" select="$sourceNodes"/>      </xsl:call-template>    </xsl:variable>    <xsl:variable name="srceSet">      <xsl:call-template name="groupAnnotationNodes">        <xsl:with-param name="srceSeries" select="$srceSeries"/>      </xsl:call-template>    </xsl:variable>    <xsl:call-template name="buildAnnotations">      <xsl:with-param name="srceSet" select="$srceSet"/>      <xsl:with-param name="pickUpProperties" select="$pickUpProperties"/>    </xsl:call-template>  </xsl:template>  <xsl:template name="buildAnnotationSeries">    <xsl:param name="sourceNodes"/>    <xsl:for-each select="$sourceNodes">      <xsl:variable name="selTxt">        <xsl:call-template name="annotationNodeType"/>      </xsl:variable>      <xsl:variable name="priType" select="substring-before($selTxt, '|')"/>      <xsl:variable name="sortKey" select="substring-before(substring-after($selTxt, '|'), '|')"/>      <xsl:variable name="elName" select="substring-after(substring-after($selTxt, '|'), '|')"/>      <xsl:choose>        <xsl:when test="$priType='t6'">          <xsl:if test="position()=1">            <xsl:element name="splitNode">              <xsl:attribute name="priType">                <xsl:value-of select="'t1'"/>              </xsl:attribute>              <xsl:attribute name="sortKey">                <xsl:value-of select="'10'"/>              </xsl:attribute>              <xsl:attribute name="elName">                <xsl:value-of select="'definition'"/>              </xsl:attribute>            </xsl:element>          </xsl:if>          <xsl:copy-of select="."/>        </xsl:when>        <xsl:otherwise>          <xsl:element name="splitNode">            <xsl:attribute name="priType">              <xsl:value-of select="$priType"/>            </xsl:attribute>            <xsl:attribute name="sortKey">              <xsl:value-of select="$sortKey"/>            </xsl:attribute>            <xsl:attribute name="elName">              <xsl:value-of select="$elName"/>            </xsl:attribute>          </xsl:element>          <xsl:choose>            <xsl:when test="$priType='t5'">              <xsl:copy>                <xsl:apply-templates select="node()"/>              </xsl:copy>            </xsl:when>            <xsl:otherwise>              <xsl:variable name="aCopy">                <xsl:copy>                  <xsl:apply-templates select="node()" mode="dropAnnotationTag"/>                </xsl:copy>              </xsl:variable>              <xsl:if test="normalize-space($aCopy)!=''">                <xsl:copy-of select="$aCopy"/>              </xsl:if>            </xsl:otherwise>          </xsl:choose>        </xsl:otherwise>      </xsl:choose>    </xsl:for-each>    <xsl:element name="endNode"/>  </xsl:template>  <xsl:template name="groupAnnotationNodes">    <xsl:param name="srceSeries" select="*"/>    <xsl:if test="$srceSeries/*[1][name()!='endNode']">      <xsl:for-each select="$srceSeries/*">        <xsl:if test="position()=1">          <!-- Opening node provides context and should always be a splitNode -->          <xsl:variable name="doSeries">            <xsl:choose>              <xsl:when test="following-sibling::splitNode[count(preceding-sibling::splitNode)=1]">                <!-- There is yet another splitNode later-->                <xsl:for-each select="$srceSeries/*[name()!='endNode']">                  <xsl:if test="(name()='splitNode' and position()=1) or (name()!='splitNode' and count(preceding-sibling::splitNode)=1)">                    <xsl:copy-of select="."/>                  </xsl:if>                </xsl:for-each>              </xsl:when>              <xsl:otherwise>                <xsl:copy-of select="$srceSeries/*[name()!='endNode']"/>              </xsl:otherwise>            </xsl:choose>            <xsl:element name="endNode"/>          </xsl:variable>          <xsl:variable name="restSeries">            <xsl:if test="following-sibling::splitNode[count(preceding-sibling::splitNode)=1]">              <!-- There is no rest unless there is another following spliyNode-->              <xsl:for-each select="$srceSeries/*[name()!='endNode']">                <xsl:if test="(name()='splitNode' and position()!=1) or (name()!='splitNode' and count(preceding-sibling::splitNode)!=1)">                  <xsl:copy-of select="."/>                </xsl:if>              </xsl:for-each>            </xsl:if>            <xsl:element name="endNode"/>          </xsl:variable>          <xsl:if test="$doSeries">            <xsl:for-each select="$doSeries/*">              <xsl:if test="position()=1 and name()!='endNode'">                <xsl:copy>                  <xsl:apply-templates select="@*"/>                  <xsl:copy-of select="following-sibling::*[name()!='endNode']"/>                </xsl:copy>              </xsl:if>            </xsl:for-each>          </xsl:if>          <xsl:call-template name="groupAnnotationNodes">            <xsl:with-param name="srceSeries" select="$restSeries"/>          </xsl:call-template>        </xsl:if>      </xsl:for-each>    </xsl:if>  </xsl:template>  <xsl:template name="buildAnnotations">    <xsl:param name="srceSet" select="*"/>    <xsl:param name="pickUpProperties" select="'F'"/>    <xsl:if test="$srceSet">      <xsl:if test="$srceSet/splitNode[@priType='t4']">        <!-- Process default or property value -->        <xsl:variable name="parentName" select="local-name(..)"/>        <xsl:variable name="parentType">          <xsl:if test="$parentName='attribute'">            <xsl:value-of select="parent::mif:attribute/mif:type/@name"/>          </xsl:if>        </xsl:variable>        <xsl:for-each select="$srceSet/splitNode[@priType='t4']">          <xsl:sort select="@sortKey"/>          <xsl:if test="@elName='defaultValue' and $parentName='attribute' and @sortKey='10' and $pickUpProperties='F'">            <xsl:variable name="defaultString">              <xsl:value-of select="*"/>            </xsl:variable>            <xsl:attribute name="{@elName}">              <xsl:choose>                <xsl:when test="$parentType='BL'">                  <xsl:choose>                    <xsl:when test="contains(string($defaultString), 'true')">                      <xsl:value-of select="'true'"/>                    </xsl:when>                    <xsl:otherwise>                      <xsl:value-of select="'false'"/>                    </xsl:otherwise>                  </xsl:choose>                </xsl:when>                <xsl:otherwise>                  <xsl:value-of select="$defaultString"/>                </xsl:otherwise>              </xsl:choose>            </xsl:attribute>          </xsl:if>          <xsl:if test="@sortKey='20' and $pickUpProperties!='F'">            <xsl:variable name="valueString">              <xsl:value-of select="*"/>            </xsl:variable>            <xsl:element name="mif:property" namespace="{$mifNamespace}">              <xsl:attribute name="name">                <xsl:value-of select="@elName"/>              </xsl:attribute>              <xsl:attribute name="value">                <xsl:value-of select="normalize-space($valueString)"/>              </xsl:attribute>            </xsl:element>          </xsl:if>        </xsl:for-each>      </xsl:if>      <xsl:if test="$pickUpProperties='F' and ($srceSet/splitNode[@priType='t1' or @priType='t2' or @priType='t3'])">        <!-- Do Annotations and AppInfo -->        <xsl:element name="mif:annotations" namespace="{$mifNamespace}">          <xsl:if test="$srceSet/splitNode[@priType='t1' or @priType='t2']">            <!-- Do Annotations -->            <xsl:element name="mif:documentation" namespace="{$mifNamespace}">                <xsl:for-each select="$srceSet/splitNode[@priType='t1' or @priType='t2' or @priType='t5']">                  <xsl:sort select="@sortKey"/>                  <xsl:choose>                    <xsl:when test="@priType='t1'">                      <xsl:element name="{concat('mif:', @elName)}" namespace="{$mifNamespace}">                        <xsl:element name="mif:text" namespace="{$mifNamespace}">                          <xsl:apply-templates mode="html" select="*"/>                        </xsl:element>                      </xsl:element>                    </xsl:when>                    <xsl:when test="@priType='t5'">                      <xsl:if test="@elName!='isImmutable'">                        <!-- Drop Property-isImmutaable as this has already been applied via the attribute of same name -->                        <xsl:element name="mif:otherAnnotation" namespace="{$mifNamespace}">                          <xsl:attribute name="type">                            <xsl:value-of select="'property'"/>                          </xsl:attribute>                          <xsl:attribute name="name">                            <xsl:value-of select="@elName"/>                          </xsl:attribute>                          <xsl:element name="mif:text" namespace="{$mifNamespace}">                            <xsl:apply-templates mode="html" select="*"/>                          </xsl:element>                        </xsl:element>                      </xsl:if>                    </xsl:when>                    <xsl:otherwise>                      <xsl:element name="mif:otherAnnotation" namespace="{$mifNamespace}">                        <xsl:attribute name="type">                          <xsl:value-of select="@elName"/>                        </xsl:attribute>                        <xsl:attribute name="name">                          <xsl:value-of select="@elName"/>                        </xsl:attribute>                        <xsl:element name="mif:text" namespace="{$mifNamespace}">                          <xsl:apply-templates mode="html" select="*"/>                          <!--                                     <xsl:copy-of select="*"/> -->                        </xsl:element>                      </xsl:element>                    </xsl:otherwise>                  </xsl:choose>                </xsl:for-each>              </xsl:element>          </xsl:if>          <xsl:if test="$srceSet/splitNode[@priType='t3']">            <!-- Do AppInfo -->            <xsl:element name="mif:appInfo" namespace="{$mifNamespace}">              <xsl:for-each select="$srceSet/splitNode[@priType='t3']">                <xsl:sort select="@sortKey"/>                <xsl:element name="{concat('mif:', @elName)}" namespace="{$mifNamespace}">                  <xsl:if test="@elName='ballotComment'">                    <xsl:attribute name="submissionId">                      <xsl:value-of select="'fromRimHx'"/>                    </xsl:attribute>                    <xsl:attribute name="name">                      <xsl:value-of select="'666'"/>                    </xsl:attribute>                    <xsl:attribute name="commentType">                      <xsl:value-of select="'Abstain'"/>                    </xsl:attribute>                  </xsl:if>                  <xsl:element name="mif:text" namespace="{$mifNamespace}">                    <xsl:apply-templates mode="html" select="*"/>                  </xsl:element>                </xsl:element>              </xsl:for-each>            </xsl:element>          </xsl:if>        </xsl:element>      </xsl:if>    </xsl:if>  </xsl:template>  <xsl:template match="*" mode="dropAnnotationTag">    <xsl:if test="translate(string(.),'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ', '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')!=''"/>    <xsl:if test="not( (local-name()='i' or local-name()='b') and (contains(text()[1],':')) )">      <xsl:copy-of select="."/>    </xsl:if>  </xsl:template>  <xsl:template name="annotationNodeType">    <!-- Use the bold or italic tag to determine the type of annotation, if any,          and  return a pipe-delimited compound result as:           1st Seg = type family as "tn"               2nd Char = integer type as:                 1 - documentation element follows                 2 - documentation type of "otherAnnotation"                 3 - appInfo                 4 - other tags - attribute default, usable properties, etc.                 5 - tags like properties that must remain part of the definition or description                 6 - non-tag to be stripped out or retained            2nd Seg = Sort sequence within type - dictated by MIF            3rd Seg = the element name as                 element name for types 1 and 3                 otherAnnotation type and name for type 2                 various for type 4                 and "stripTag" or "ignore" for non-tags ("ignore" means keep all)   Thus      t1 documenttion        10 definition        15 description        20 usageConstraint        25 usageNotes        30 rationale        35 requirements        40 designComments        45 walkthrough        50 appendix      t2 75 otherAnnotation      t3 appInfo        10 mapping        15 formalConstraint        20 openIssue        25 staticExample        30 ballotComment        35 changeRequest        40 deprecationInfo      t4 - other attributes        10 defaultValue for Attribute        20 property      t5 - Assert or Retain as tag in definition or description        90 Property assertion      t6 - keep as part of other annotation        10 stripTag - strip the tag from the retained content        20 ignore - retain the tag as is   -->    <xsl:variable name="selText">      <xsl:for-each select="node()[local-name()='i' or local-name()='b'][contains(text()[1],':')][1]">        <xsl:value-of select="substring(translate( text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ', 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'), 1, 7)"/>      </xsl:for-each>    </xsl:variable>    <xsl:choose>      <xsl:when test="$selText='definit'">        <xsl:value-of select="'t1|10|definition'"/>      </xsl:when>      <xsl:when test="$selText='descrip'">        <xsl:value-of select="'t1|15|description'"/>      </xsl:when>      <xsl:when test="$selText='usageco'">        <xsl:value-of select="'t1|20|usageConstraint'"/>      </xsl:when>      <xsl:when test="$selText='usageno'">        <xsl:value-of select="'t1|25|usageNotes'"/>      </xsl:when>      <xsl:when test="$selText='rationa'">        <xsl:value-of select="'t1|30|rationale'"/>      </xsl:when>      <xsl:when test="$selText='require'">        <xsl:value-of select="'t1|35|requirements'"/>      </xsl:when>      <xsl:when test="$selText='designc'">        <xsl:value-of select="'t1|40|designComments'"/>      </xsl:when>      <xsl:when test="$selText='example'">        <xsl:value-of select="'t2|75|examples'"/>      </xsl:when>      <xsl:when test="$selText='mapping'">        <xsl:value-of select="'t3|10|mapping'"/>      </xsl:when>      <xsl:when test="$selText='formalc'">        <xsl:value-of select="'t3|15|formalConstraint'"/>      </xsl:when>      <xsl:when test="$selText='openiss'">        <xsl:value-of select="'t3|20|openIssue'"/>      </xsl:when>      <!--         <xsl:when test="$selText='statice'">            <xsl:value-of select="'t3|25|staticExample'"/>         </xsl:when> -->      <xsl:when test="$selText='ballotc'">        <xsl:value-of select="'t3|30|ballotComment'"/>      </xsl:when>      <!--         <xsl:when test="$selText='changer'">            <xsl:value-of select="'t3|35|changeRequest'"/>         </xsl:when> -->      <xsl:when test="$selText='depreca'">        <xsl:value-of select="'t3|40|deprecationInfo'"/>      </xsl:when>      <xsl:when test="$selText='default'">        <xsl:value-of select="'t4|10|defaultValue'"/>      </xsl:when>      <xsl:when test="$selText='propert'">        <xsl:variable name="propertyName">          <xsl:for-each select="node()[local-name()='i' or local-name()='b'][contains(text(),':')][1]">            <xsl:value-of select="substring-before(substring-after(text(),'Property-'), ':')"/>          </xsl:for-each>        </xsl:variable>        <xsl:choose>          <xsl:when test="$propertyName='isDocumentCharacteristic'">            <xsl:value-of select="'t4|20|isDocumentCharacteristic'"/>          </xsl:when>          <xsl:otherwise>            <xsl:value-of select="concat('t5|90|', $propertyName)"/>          </xsl:otherwise>        </xsl:choose>      </xsl:when>      <xsl:otherwise>        <xsl:value-of select="'t6|20|ignore'"/>      </xsl:otherwise>    </xsl:choose>  </xsl:template></xsl:stylesheet>